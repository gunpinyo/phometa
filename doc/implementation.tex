\documentclass[master.tex]{subfiles}
\begin{document}
\chapter{Implementation}
\label{chap:implementation}

This chapter aims to illustrate the high-level implementation of Phometa. So
that the reader will get a rough idea on how Phometa works.

\section{Decision on programming language}
Elm\supercite{elm-official-website} is a functional reactive programming
language. It allows programmers to create web applications by declaratively
coding in Haskell-like language then compiling the program to JavaScript.

One of the most attractive features of Elm is its reactivity. This idea
introduces a new data type called ``Signal''\footnote{Signal has been removed
  from Elm version 0.17 recently, however, Phometa uses Elm version 0.16 so it
  is fine to talk about Signal.} which is a data type that can change over time.
For example, \elmtt{Mouse.isDown : Signal Bool} represents a Boolean that holds
``True'' when the mouse is pressed, \elmtt{Window.dimensions : Signal (Int,
  Int)} represents a pair of integers that hold current width and height of the
window respectively. Custom Signal can be created using higher order functions
as in this example,
\begin{lstlisting}[language=elm]
Signal.map  : (a -> b) -> Signal a -> Signal b

window_area : Signal Int
window_area = Signal.map (\(w, h) -> w * h) Window.dimensions
\end{lstlisting}
\elmtt{window_area} is a signal that represents the area of current window. If
you resize the window, this value will change on real time. This is bacause when
the dimensions of the window is changed, it will notify
\elmtt{Window.dimensions} to update its value, \elmtt{Window.dimensions} in
turn, notifies \elmtt{window_area} to update its value as well.

These Signals can link together to form a dependency graph, eventually we will
create \elmtt{main : Signal Html} which is a HTML representation that can change
over time, Elm will detect this \elmtt{main} and render it in a web-browser. For
example,

\begin{lstlisting}[language=elm]
import Mouse
import Signal exposing (Signal)
import Html exposing (Html, div, text)
import Html.Attributes exposing (style)

view : Bool -> Html
view is_clicked =
  if is_clicked then div [style [("color", "green")]]
                         [text "Clicked !!"]
                else text "Please click this page."

main : Signal Html
main = Signal.map view Mouse.isDown
\end{lstlisting}

Once this code is complied, we will get HTML file (with JavaScript embedded)
such that if it is opened in web-browser, it will show text ``Please click this
page.'', if you click somewhere in the page, the text will change to ``Clicked
!!'' with green background colour, this will change back when you release the
mouse.

The example above shows that Elm could replace all of HTML, JavaScript, and even
CSS. In another word, the entire front-end development could be done in one
purely functional language. Therefore, Elm is a good candidate to be used as
main programming language for web-based application like Phometa.

For more information, please see Elm official website at \url{elm-lang.org}.

\section{Model-Controller-View Architecture}

Recall from the previous example, you could see that the HTML will depend
directly on corresponding Signal(s) but in real application we need a way to
store variables, this is achievable by the following function

\begin{lstlisting}[language=elm]
Signal.foldp : (a -> b -> b) -> b -> Signal a -> Signal b
\end{lstlisting}

Initially, the Signal generated form \elmtt{Signal.foldp} will have a value the
same as the second argument, then whenever the Signal from the third argument is
updated (possibly with the same value), it will be \emph{reduced} with the
current output Signal in order to get new output Signal. For example,

\begin{lstlisting}[language=elm]
click_total : Signal Int
click_total =
  let fold_func clicked acc = if clicked then acc + 1 else acc
   in Signal.foldp fold_func 0 Mouse.isDown
\end{lstlisting}

\elmtt{click_total} is a Signal that store an integers. Initially, it starts
with $0$. When user click mouse on the page, \elmtt{Mouse.isDown} will notify
\elmtt{click_total} to invoke \elmtt{fold_func}, and the value of this Signal
will updated to $1$. If you click it again it will be $2$, $3$, $4$, and so on.

In Phometa, an accumulator of \elmtt{Signal.foldp} is \elmtt{Model} represented
the global state of the entire program. The third argument (input Signal) of
\elmtt{Signal.foldp} is \elmtt{Action} represented the Signal that change every
time when user pressing the keyboard or clicking a button with Phometa. We could
define the main entry of Phometa program as the following\footnote{Phometa code
  represented here is just a simplify version, I can't show the real one because
  MCV architecture is modified to support back-end communication so it is harder
  to understand.}

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
module Main where

import Html exposing (Html)
import Keyboard exposing (keysDown)
import Set exposing (Set)
import Models.Model exposing (Model)
import Models.ModelUtils exposing (init_model)
import Models.Action exposing (Action (..) , mailbox, address)
import Updates.Update exposing (update)
import Views.View exposing (view)

keyboard_signal : Signal Action
keyboard_signal = Signal.map
  (Set.toList >> List.sort >> ActionKeystroke) keysDown

action_signal : Signal Action
action_signal = Signal.merge mailbox.signal keyboard_signal

model_signal : Signal Model
model_signal = Signal.foldp update init_model action_signal

main : Signal Html
main = Signal.map view model_signal
\end{lstlisting}
\end{framed}
\caption{Simplified version of \texttt{Main.elm}}
\label{fig:implementation-simplified-main}
\end{figure}

By using \elmtt{Signal.foldp} together with \elmtt{update : Action -> Model ->
  Model}, we achieve \elmtt{model_signal} which is a Signal represented the
current global state of Phometa, which, in turn, can be transformed using
\elmtt{Signal.foldp} together with \elmtt{view : Model -> Html} to achieve
\elmtt{main} which represented the current HTML page.

Now, it becomes clear that Model-Controller-View architecture could be separated
by \elmtt{Model}, \elmtt{update : Action -> Model -> Model}, and \elmtt{view :
  Model -> Html} respectively.

\newpage

\section{The Anatomy of Phometa Repository}

Phometa is been developed using \emph{Git} as the version control and hosted
at

\url{https://github.com/gunpinyo/phometa}.

The Phometa repository \footnote{Please do not confuse with proofs repository
  which is the root package of proofs content} has the structure as the
following

\begin{itemize}
\item \texttt{\textbf{build/}} --- contains complied version of Phometa and PDF
  version of this report.

\item \texttt{\textbf{doc/}} --- contains source code and supplementary images
  of this report.

\item \texttt{\textbf{scripts/}} --- contains scripts that can complie source
  code, run test suites, etc.

\item \texttt{\textbf{src/}} --- contains the entire source code of Phometa
  \begin{itemize}
  \renewcommand{\labelitemii}{$\star$}
  \item \texttt{\textbf{Naive/}} --- contains naive JavaScript functions that
    Elm functions can call.
  \item \texttt{\textbf{Tools/}} --- contains additional functions that are
    useful in general.
  \item \texttt{\textbf{Models/}} --- contains dependencies of \elmtt{Model} and
    its utilities.
  \item \texttt{\textbf{Updates/}} --- contains dependencies of \elmtt{updates}
    and its utilities.
  \item \texttt{\textbf{Views/}} --- contains dependencies of \elmtt{view}
    and its utilities.
  \item \texttt{\textbf{Main.elm}} --- the main entry of Phometa that
    wire up MCV components.
  \item \texttt{\textbf{repository.json}} --- initial proofs repository that
    contains standard library.
  \item \texttt{\textbf{phometa-server.py}} --- a python scripts back-end server.
  \item \texttt{\textbf{naive.js}} --- JavaScript that will be ship with
    complied version of Phometa.
  \item \texttt{\textbf{style.scss}} --- layout and theme of Phometa.
  \end{itemize}
\item \texttt{\textbf{tests/}} --- contains tests suites
\item \texttt{\textbf{.gitignore}} --- specification of files that will be
  ignored by Git.
\item \texttt{\textbf{.travis.yml}} --- meta data regarding to Travis continuous
  integration.
\item \texttt{\textbf{LICENSE}} --- 3-clause BSD license.
\item \texttt{\textbf{README.md}} --- summary information for of this repository.
\item \texttt{\textbf{elm-package.json}} --- meta data regarding to Elm
  dependencies.
\item \texttt{\textbf{logo.png}} --- logo that will be used for favicon.

\end{itemize}

Please note that some files are omitted here due to limited space.

\newpage

\section{Model, Command, Keymap, and Action}
\elmtt{Model} is defined in \texttt{src/Models/Model.elm} as the following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias Model =
  { config       : Config
  , root_package : Package
  , root_keymap  : Keymap
  , grids        : Grids
  , pane_cursor  : PaneCursor
  , mode         : Mode
  , message_list : MessageList
  , environment  : Environment
  }
\end{lstlisting}
\end{framed}
\caption{Declaration of \elmtt{Model}}
\label{fig:implementation-model}
\end{figure}

A function that can manipulate \elmtt{Model} has type signature as
\begin{lstlisting}[language=elm]
type alias Command = Model -> Model
\end{lstlisting}

\elmtt{Action} is defined in \texttt{src/Models/Action.elm}
as the following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type Action
  = ActionNothing
  | ActionCommand Command
  | ActionKeystroke Keystroke
\end{lstlisting}
\end{framed}
\caption{Declaration of \elmtt{Action}}
\label{fig:implementation-action}
\end{figure}

One way to interact with Phometa is to click some button (or any clickable
area), when this is clicked, it will update the value of \elmtt{action_signal}
to ``\elmtt{ActionCommand cmd}'' where \elmtt{cmd} is an instance of
\elmtt{Command} injected to that button earlier.

\elmtt{Signal.foldp} will detect change in \elmtt{action_signal} so it applies
function \elmtt{update} with ``\elmtt{ActionCommand cmd}'' to
\elmtt{model_signal}. The function \elmtt{update}, in turn, will apply command
\elmtt{cmd} to current model and this is how model can be updated.

Again, \elmtt{Signal.map} will detect change in \elmtt{action_model} so it
applies function \elmtt{view} with current model to get latest HTML instance,
please note that \elmtt{view} might inject further commands to buttons, if
user click any button, then the entire process will happen again.

Another way to interact with Phometa is to press some keystroke, this will make
\elmtt{action_signal} changes to ``\elmtt{ActionKeystroke keystroke}'', where
\elmtt{keystroke} is a \elmtt{List} of \elmtt{KeyCode} obtained from
\elmtt{Keyboard.keysDown}.

\elmtt{Signal.foldp} will detect change in \elmtt{action_signal} so it applies
function \elmtt{update} with ``\elmtt{ActionKeystroke keystroke}'' to
\elmtt{model_signal}. The function \elmtt{update}, in turn, will search a
command that corresponded to this keystroke from \elmtt{model.root_keymap} to
apply such a command with current model. Now, the remaining process is the same
as when we click button.

\section{Structure of Proofs Repository}
In this section, we will show the complete internal representation of a proofs
repository. All codes inside this section come from
\texttt{src/Models/RepoModel.elm}

Let define some common elements first\footnote{\elmtt{Arguments} depends on
  \elmtt{RootTerm} which will be defined later in this section}.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias ContainerName = String
type alias ContainerPath = List ContainerName
type alias Format = String
type alias VarName = String
type alias Parameters = List { grammar  : GrammarName
                             , var_name : VarName }
type alias Arguments = List RootTerm
\end{lstlisting}
\end{framed}
\caption{Representation of common elements that will be used later on}
\label{fig:implementation-repo-common}
\end{figure}

Now, we can define a proof repository which is just a big \elmtt{Package} stored
in global model named \elmtt{model.root\_package} and can be defined as the
following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias PackageName = ContainerName
type alias PackagePath = List PackageName
type alias Package = { is_folded : Bool
                     , dict : Dict ContainerName PackageElem }
type PackageElem
  = PackageElemPkg Package
  | PackageElemMod Module
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Package} and related components.}
\label{fig:implementation-repo-package}
\end{figure}

We could think a \elmtt{Package} roughly as a collection containing other
\elmtt{Package}s and \elmtt{Module}s. We also need \elmtt{PackagePath} to
reference a package relatively to root package.

\elmtt{Module} is a collection containing nodes. \elmtt{ModulePath} is a
unique reference from root package to this module.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias ModuleName = ContainerName
type alias ModulePath = { package_path : PackagePath
                        , module_name  : ModuleName }
type alias Module = { is_folded : Bool
                    , nodes     : OrderedDict NodeName Node }
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Module} and related components.}
\label{fig:implementation-repo-module}
\end{figure}

There are four types of \elmtt{Node} which are \elmtt{Comment}, \elmtt{Grammar},
\elmtt{Rule}, and \elmtt{Theorem}\footnote{\elmtt{Bool} that follows
  \elmtt{NodeTheorem} tells whether that theorem has been converted to lemma or
  not}. \elmtt{NodePath} is a unique reference from root package to this
node.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias NodeName = ContainerName

type alias NodePath =
  { module_path : ModulePath
  , node_name   : NodeName
  }

type Node
  = NodeComment String
  | NodeGrammar Grammar
  | NodeRule Rule
  | NodeTheorem Theorem Bool -- Bool = has_locked

type NodeType
  = NodeTypeComment
  | NodeTypeGrammar
  | NodeTypeRule
  | NodeTypeTheorem
\end{lstlisting}
% type alias NodeName = ContainerName
% type alias NodePath = { module_path : ModulePath
%                       , node_name   : NodeName }
% type Node = NodeComment String
%           | NodeGrammar Grammar
%           | NodeRule Rule
%           | NodeTheorem Theorem Bool
% type NodeType = NodeTypeComment
%               | NodeTypeGrammar
%               | NodeTypeRule
%               | NodeTypeTheorem
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Node} and related components.}
\label{fig:implementation-repo-node}
\end{figure}

We could define \elmtt{Grammar} as the following,

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias GrammarName = String

type alias Grammar =
  { is_folded     : Bool
  , has_locked    : Bool
  , metavar_regex : Maybe Regex
  , literal_regex : Maybe Regex
  , choices       : List GrammarChoice
  }

type alias GrammarChoice = StripedList Format GrammarName
\end{lstlisting}
% type alias GrammarName = String
% type alias Grammar = { is_folded     : Bool
%                      , has_locked    : Bool
%                      , metavar_regex : Maybe Regex
%                      , literal_regex : Maybe Regex
%                      , choices       : List GrammarChoice }
% type alias GrammarChoice = StripedList Format GrammarName
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Grammar} and related components.}
\label{fig:implementation-repo-grammar}
\end{figure}

\elmtt{StripedList Format GrammarName} is just a pair of ``list of
\elmtt{Format}'' and ``list of \elmtt{GrammarName}'' but it also ensure that
length of ``list of \elmtt{Format}'' is longer than ``list of
\elmtt{GrammarName}'' by exactly 1.

Next is a term, which can be defined like this,

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type Term
  = TermTodo
  | TermVar VarName
  | TermInd GrammarChoice (List Term)

type alias RootTerm =
  { grammar : GrammarName
  , term : Term
  }

type VarType
  = VarTypeMetaVar
  | VarTypeLiteral
\end{lstlisting}
% type Term = TermTodo
%           | TermVar VarName
%           | TermInd GrammarChoice (List Term)
% type alias RootTerm = { grammar : GrammarName
%                       , term : Term }
% type VarType = VarTypeMetaVar
%              | VarTypeLiteral
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Term} and related components.}
\label{fig:implementation-repo-term}
\end{figure}

We usually use \elmtt{RootTerm} as a term at the top level, this is because it
know its known grammar. In fact, \elmtt{Term} is just an auxiliary model of
\elmtt{RootTerm}. Please note that it is possible to fine the grammar of every
sub-term of a \elmtt{RootTerm}, because we can refer to \elmtt{grammar}
property of \elmtt{RootTerm} for top level and refer to \elmtt{GrammarChoice}
of \elmtt{TermInd} for deeper sub-term.

Once \elmtt{RootTerm} has been defined, we can define \elmtt{Rule} and
\elmtt{Theorem} as the following,

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias RuleName = String

type alias Rule =
  { is_folded       : Bool
  , has_locked      : Bool
  , allow_reduction : Bool
  , parameters      : Parameters
  , conclusion      : RootTerm
  , premises        : List Premise
  }

type Premise
  = PremiseDirect RootTerm
  | PremiseCascade (List PremiseCascadeRecord)

type alias PremiseCascadeRecord =
  { rule_name : RuleName
  , pattern : RootTerm
  , arguments : Arguments
  , allow_unification : Bool
  }
\end{lstlisting}

% type alias RuleName = String
% type alias Rule = { is_folded       : Bool
%                   , has_locked      : Bool
%                   , allow_reduction : Bool
%                   , parameters      : Parameters
%                   , conclusion      : RootTerm
%                   , premises        : List Premise }
% type Premise = PremiseDirect RootTerm
%              | PremiseCascade (List PremiseCascadeRecord)
% type alias PremiseCascadeRecord = { rule_name : RuleName
%                                   , pattern : RootTerm
%                                   , arguments : Arguments
%                                   , allow_unification : Bool }
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Rule} and related components.}
\label{fig:implementation-repo-rule}
\end{figure}


\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias TheoremName = String

type alias Theorem =
  { is_folded : Bool
  , goal      : RootTerm
  , proof     : Proof
  }

type Proof
  = ProofTodo
  | ProofTodoWithRule RuleName Arguments
  | ProofByRule RuleName Arguments PatternMatchingInfo
      (List Theorem)
  | ProofByLemma TheoremName PatternMatchingInfo
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Theorem} and related components.}
\label{fig:implementation-repo-theorem}
\end{figure}

\elmtt{PatternMatchingInfo} is a result when a pattern matching is successful
and can be defined as the following,


\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias SubstitutionList =
  List { old_var : VarName
       , new_root_term : RootTerm
       }

type alias PatternMatchingInfo =
  { pattern_variables : Dict VarName RootTerm
  , substitution_list : SubstitutionList
  }
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{PatternMatchingInfo} and related components.}
\label{fig:implementation-repo-pattern-matching-info}
\end{figure}

As we know that terms that match to the same pattern variable will be unified
during matching, \elmtt{SubstitutionList} tell us that what meta-variables
(\elmtt{old\_var}) should be replaced \elmtt{new\_root\_term}. The order of
substitution is important as later substitution might depend on earlier one. Now
we can guarantee that, after unification, each pattern variable will match to
only one term, this make it possible to create a dictionary
\elmtt{pattern\_variables} that map these pattern variables to the corresponded
terms.

\section{Pattern Matching and Unification}
Although it is impossible to show all of codes written in Phometa, there is a
faction of code related to \emph{Pattern Matching} that is small enough to be
described entirely, it is also one of the most interesting part as well.

Please note that this section only described how pattern matching works. For the
supplementary source code, please see appendix chapter
\ref{chap:supplementary_source_code}.

Let start with the most important function, \elmtt{pattern\_match} is a function
that pattern match \elmtt{pattern} against \elmtt{target}, if success, it will
the return pattern matching information as described in previous section.
Another function is \elmtt{pattern\_match\_multiple} which is the same as
previous function but receive a list of pair of \elmtt{(pattern, target)} rather
than just one \elmtt{pattern} and one \elmtt{target}. These two are shown in
figure \ref{fig:supp-pattern-matching-info}.

\newpage

Both of functions above call function \elmtt{pattern\_match\_get\_vars\_dict} that
perform the actual pattern matching and return a dictionary that map each
pattern variable to a list of terms. The the pattern match process is shown in
figure \ref{fig:supp-pattern-pattern-match-get-vars-dict} and can be
described as the following
\begin{itemize}
\item If the grammar of pattern and target is not the same, fail immediately.
\item If any of pattern or target is unfinished term, fail immediately.
\item If pattern is a variable, success immediately with that variable
  map to the target.
\item If target is a variable but pattern is not, fail immediately, this is
  one way matching.
\item the only possibility left is both of them are
  \elmtt{TermInd}\footnote{A term can be either unfinished, variable, or
    \elmtt{TermInd}}, so it can process as the following
  \begin{itemize}
  \item If the grammar choice of pattern and target is not the same, fail
    immediately.
  \item Otherwise, recursively call current function on their sub terms,
    \begin{itemize}
      \item If any of sub-term fail pattern matching, then the entire function fail.
      \item Otherwise, merge these sub-result together and successfully return it.
    \end{itemize}
  \end{itemize}
\end{itemize}

After \elmtt{pattern\_match\_get\_vars\_dict} produces matching dictionary. \\
\elmtt{vars\_dict\_to\_pattern\_matching\_info} as shown in figure
\ref{fig:supp-vars-dict-to-pattern-matching-info} will try to fit this into
\elmtt{PatternMatchingInfo}. This can be done by finding a
\elmtt{SubstitutionList} that can eliminate all of ambiguity among terms which
are the value of matching dictionary. This \elmtt{SubstitutionList} can be found
by using the following method.
\begin{itemize}
\item For each pattern variable, check whether it is meta variable or literal.
\item If it is meta variable, unify corresponded terms to each other then append
  these unification result to the main \elmtt{SubstitutionList}.
\item If it is literal, check that each of term is that exact variable as well,
  otherwise, fail.
\end{itemize}

Then we can substitute this \elmtt{SubstitutionList} to the matching directly to
get \elmtt{pattern\_variables}, hence be able to return
\elmtt{PatternMatchingInfo} as expected.

Function \elmtt{unify} as described in figure \ref{fig:supp-unify} receives term
\elmtt{a} and \elmtt{b} then try to build most general unifier (mgu) which is
the most general substitution list that is specific enough to make term
\elmtt{a} and \elmtt{b} identical. This unification process is similar to
pattern matching in \elmtt{pattern\_match\_get\_vars\_dict} but this is two way
matching and it is aware whether a variable is meta variable or literal.

There are also other several auxiliary functions for pattern matching as
described in figure \ref{fig:supp-auxiliary}.


\section{Building a Complied Version}
We can build the complied version of Phometa by go to the top directory of
Phometa repository then execute \texttt{./scripts/build.sh}. This will process
as the following
\begin{itemize}
\item create \texttt{build/} (if doesn't exist) or clean it (if doesn't empty)
\item compile(\LaTeX) the document in \texttt{doc/} and copy the main PDF file to \texttt{build/}
\item compile(Sass) \texttt{src/style.scss} to \texttt{build/style.css}
\item copy the following files to \texttt{build/}
  \begin{itemize}
  \item \texttt{src/naive.js}
  \item \texttt{src/repository.json}
  \item \texttt{src/phometa-server.py}
  \item \texttt{logo.png}
  \end{itemize}
\item compile(Elm) \texttt{src/Main.elm} to \texttt{build/phometa.html}
\item compress everything in \texttt{build/} to \texttt{build/phometa.tar.gz}
\end{itemize}

Please note that Elm compilation will consult \texttt{elm-package.json} for meta
data. The dependency of target Elm file will be complied recursively. It can be
outputted as HTML file (for standalone application) or JavaScript file (to
embedded it as an element of bigger application).

\section{Back-End Communication}
There is a python server template from
\url{https://gist.github.com/UniIsland/3346170} which allows client to
download and upload local files directly in the server.

This server template, with some modification, allows us to create a local server
to serve \texttt{phometa.html} which is the main application that user will
interact with. \texttt{phometa.html}, in turn, will load further resource such
as \texttt{naive.js} (for naive code that can't be done directly in Elm) and
\texttt{style.css} (for theme of Phometa).

Once the setup is completed, Phometa will automatically load the repository by
sending Ajax request to load \texttt{repository.json} from the server, and then,
it will decode this json file to get instance of \elmtt{Package} and will set
this to \elmtt{model.root_package}.

Most of operation after this doesn't require further communication with the
server. Nevertheless, if user would like to save the repository, Phometa will
encode \elmtt{model.root_package} and send Ajax request to upload this as
\texttt{repository.json}.

\section{Testing / Continious Integration}
Functional programming makes testing really easy. In order to test a function,
we need to create a test suite and call that function with several inputs then
check whether the outputs are the same as expectation or not.

For example, we want to test a function \elmtt{list\_insert} as the following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
list_insert : Int -> a -> List a -> List a
list_insert n x xs =
  if n <= 0 then x :: xs else
    case xs of
      []      -> [x]
      y :: ys -> y :: (list_insert (n - 1) x ys)
\end{lstlisting}
\end{framed}
\caption{Function \elmtt{list\_insert} from \texttt{src/Tools/Utils.elm}}
\label{fig:implementation-test-src}
\end{figure}

We could write a test suite for \elmtt{list\_insert} in the test suite of its module like this

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
module Tests.Tools.Utils where

import ElmTest exposing (Test, test, suite, assert,
                         assertEqual, assertNotEqual)
import Tools.Utils exposing (..)

tests : Test
tests = suite "Tools.Utils" [
  suite "list_skeleton" [...],
  suite "list_insert" [
    test "n < 0" <|
      assertEqual [7, 6, 4, 9] (list_insert (-1) 7 [6, 4, 9]),
    test "n = 0" <|
      assertEqual [7, 6, 4, 9] (list_insert 0 7 [6, 4, 9]),
    test "n in range" <|
      assertEqual [6, 4, 7, 9] (list_insert 2 7 [6, 4, 9]),
    test "n >= length" <|
      assertEqual [6, 4, 9, 7] (list_insert 10 7 [6, 4, 9]),
    ... ],
  suite "parity_pair_extract" [...],
  suite "remove_list_duplicate" [...],
  ... ]
\end{lstlisting}
\end{framed}
\caption{The test suite for module \texttt{src/Tools/Utils.elm}}
\label{fig:implementation-test-test}
\end{figure}

A test suite of each module will be included in the main test suite as the
following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
module Main where

import Task
import Console exposing (run)
import ElmTest exposing (Test, suite, consoleRunner)

...
import Tests.Tools.Utils
...

tests : Test
tests = suite "Tests" [ ... , Tests.Tools.Utils.tests, ... ]

port runner : Signal (Task.Task x ())
port runner = run (consoleRunner tests)
\end{lstlisting}
\end{framed}
\caption{The main test suite which is at \texttt{tests/Tests/Main.elm}}
\label{fig:implementation-test-main}
\end{figure}

To run the main test suite, go to top level of Phometa repository\\ then execute
\texttt{./scripts/tests.sh} which will be processed as the following.
\begin{itemize}
\item compile \texttt{tests/Tests/Main.elm} to \texttt{raw-tests.js}
\item convert \texttt{raw-tests.js} to \texttt{tests.js} using external bash
  script\footnote{\url{https://raw.githubusercontent.com/laszlopandy/elm-console/master/elm-io.sh}}.
\item execute \texttt{tests.js} by \emph{Node.js}, this will show the testing result.
\end{itemize}

Please note that the test suite doesn't have 100\% coverage and functions
related to HTML are not testable using this method.

\emph{Travis CI} is used for continuous integration. Basically, every time when
something is pushed to \emph{GitHub}, Travis CI will check \texttt{.travis.yml}
this will result in the main test suite being executed in virtual machine using
similar testing process above.


\end{document}