\documentclass[master.tex]{subfiles}
\begin{document}
\chapter{Implementation}

This chapter aims to illustrate high-level implementation of Phometa. Reader
will get a roughly idea on how does Phometa works.

\section{Decision on programming language}
Elm\supercite{elm-official-website} is a functional reactive programming
language. It allows programmer to create web application by declaratively coding
in Haskell-like language then compile the program to JavaScript.

One of the most attractive feature of Elm is its reactivity. This idea
introduces a new data type called ``Signal''\footnote{Signal has been removed
  from Elm version 0.17 recently, however, Phometa uses Elm version 0.16 so it
  is fine to talk about Signal.} which is a data type that can change over time.
For example, \elmtt{Mouse.isDown : Signal Bool} represents Boolean that holds
``True'' when the mouse is pressed, \elmtt{Window.dimensions : Signal (Int,
  Int)} represents a pair of integers that holds current width and height of the
window respectively. Custom Signal can be created using higher order functions
as this example,
\begin{lstlisting}[language=elm]
Signal.map  : (a -> b) -> Signal a -> Signal b

window_area : Signal Int
window_area = Signal.map (\(w, h) -> w * h) Window.dimensions
\end{lstlisting}
\elmtt{window_area} is a signal that represents the area of current window, if
you resize the window, this value will change on real time. This is bacause when
the dimensions of the window is changed, it will notify
\elmtt{Window.dimensions} to updated its value, \elmtt{Window.dimensions} in
tern, notify \elmtt{window_area} to update it value as well.

These Signals can link together to form a dependency graph, eventually we will
create \elmtt{main : Signal Html} which is a HTML representation that can change
over time, Elm will detect this \elmtt{main} and render it in web-browser. For
example,

\begin{lstlisting}[language=elm]
import Mouse
import Signal exposing (Signal)
import Html exposing (Html, div, text)
import Html.Attributes exposing (style)

view : Bool -> Html
view is_clicked =
  if is_clicked then div [style [("color", "green")]]
                         [text "Clicked !!"]
                else text "Please click this page."

main : Signal Html
main = Signal.map view Mouse.isDown
\end{lstlisting}

Once this code is complied, we will get HTML file (with JavaScript embedded)
such that if it is opened in web-browser, it will show text ``Please click this
page.'', if you click somewhere in the page, the text will change to ``Clicked
!!'' with green background colour, this will change back when you release the
mouse.

The example above shows that Elm could replace all of HTML, JavaScript, and even
CSS. In another word, the entire front-end development could be done in one
purely functional language. Therefore, Elm is a good candidate to be used as
main programming language for web-based application like Phometa.

For more information, please see Elm official website at \url{elm-lang.org}.

\section{Model-Controller-View Architecture}

Recall from the previous example, you could see that the HTML will depend
directly on corresponding Signal(s) but in real application we need a way to
store variables, this is achievable by the following function

\begin{lstlisting}[language=elm]
Signal.foldp : (a -> b -> b) -> b -> Signal a -> Signal b
\end{lstlisting}

Initially, the Signal generated form \elmtt{Signal.foldp} will have a value the
same as the second argument, then whenever the Signal from the third argument is
updated (possibly with the same value), it will be \emph{reduced} with the
current output Signal in order to get new output Signal. For example,

\begin{lstlisting}[language=elm]
click_total : Signal Int
click_total =
  let fold_func clicked acc = if clicked then acc + 1 else acc
   in Signal.foldp fold_func 0 Mouse.isDown
\end{lstlisting}

\elmtt{click_total} is a Signal that store an integers. Initially, it starts
with $0$. When user click mouse on the page, \elmtt{Mouse.isDown} will notify
\elmtt{click_total} to invoke \elmtt{fold_func}, and the value of this Signal
will updated to $1$. If you click it again it will be $2$, $3$, $4$, and so on.

In Phometa, an accumulator of \elmtt{Signal.foldp} is \elmtt{Model} represented
the global state of the entire program. The third argument (input Signal) of
\elmtt{Signal.foldp} is \elmtt{Action} represented the Signal that change every
time when user pressing the keyboard or clicking a button with Phometa. We could
define the main entry of Phometa program as the following\footnote{Phometa code
  represented here is just a simplify version, I can't show the real one because
  MCV architecture is modified to support back-end communication so it is harder
  to understand.}

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
module Main where

import Html exposing (Html)
import Keyboard exposing (keysDown)
import Set exposing (Set)
import Models.Model exposing (Model)
import Models.ModelUtils exposing (init_model)
import Models.Action exposing (Action (..) , mailbox, address)
import Updates.Update exposing (update)
import Views.View exposing (view)

keyboard_signal : Signal Action
keyboard_signal = Signal.map
  (Set.toList >> List.sort >> ActionKeystroke) keysDown

action_signal : Signal Action
action_signal = Signal.merge mailbox.signal keyboard_signal

model_signal : Signal Model
model_signal = Signal.foldp update init_model action_signal

main : Signal Html
main = Signal.map view model_signal
\end{lstlisting}
\end{framed}
\caption{Simplified version of \texttt{Main.elm}}
\label{fig:implementation-simplified-main}
\end{figure}

By using \elmtt{Signal.foldp} together with \elmtt{update : Action -> Model ->
  Model}, we achieve \elmtt{model_signal} which is a Signal represented the
current global state of Phometa, which, in tern, can be transformed using
\elmtt{Signal.foldp} together with \elmtt{view : Model -> Html} to achieve
\elmtt{main} which represented the current HTML page.

Now, it becomes clear that Model-Controller-View architecture could be separated
by \elmtt{Model}, \elmtt{update : Action -> Model -> Model}, and \elmtt{view :
  Model -> Html} respectively.

\newpage

\section{The Anatomy of Phometa Repository}

Phometa is been developed using \emph{Git} as the version control and hosted
at

\url{https://github.com/gunpinyo/phometa}.

The Phometa repository \footnote{Please do not confuse with proofs repository
  which is the root package of proofs content} has the structure as the
following

\begin{itemize}
\item \texttt{\textbf{build/}} --- contains complied version of Phometa and PDF
  version of this report.

\item \texttt{\textbf{doc/}} --- contains source code and supplementary images
  of this report.

\item \texttt{\textbf{scripts/}} --- contains scripts that can complie source
  code, run test suites, etc.

\item \texttt{\textbf{src/}} --- contains the entire source code of Phometa
  \begin{itemize}
  \renewcommand{\labelitemii}{$\star$}
  \item \texttt{\textbf{Naive/}} --- contains naive JavaScript functions that
    Elm functions can call.
  \item \texttt{\textbf{Tools/}} --- contains additional functions that are
    useful in general.
  \item \texttt{\textbf{Models/}} --- contains dependencies of \elmtt{Model} and
    its utilities.
  \item \texttt{\textbf{Updates/}} --- contains dependencies of \elmtt{updates}
    and its utilities.
  \item \texttt{\textbf{Views/}} --- contains dependencies of \elmtt{view}
    and its utilities.
  \item \texttt{\textbf{Main.elm}} --- the main entry of Phometa that
    wire up MCV components.
  \item \texttt{\textbf{repository.json}} --- initial proofs repository that
    contains standard library.
  \item \texttt{\textbf{phometa-server.py}} --- a python scripts back-end server.
  \item \texttt{\textbf{naive.js}} --- JavaScript that will be ship with
    complied version of Phometa.
  \item \texttt{\textbf{style.scss}} --- layout and theme of Phometa.
  \end{itemize}
\item \texttt{\textbf{tests/}} --- contains tests suites
\item \texttt{\textbf{.gitignore}} --- specification of files that will be
  ignored by Git.
\item \texttt{\textbf{.travis.yml}} --- meta data regarding to Travis continuous
  integration.
\item \texttt{\textbf{LICENSE}} --- 3-clause BSD license.
\item \texttt{\textbf{README.md}} --- summary information for of this repository.
\item \texttt{\textbf{elm-package.json}} --- meta data regarding to Elm
  dependencies.
\item \texttt{\textbf{logo.png}} --- logo that will be used for favicon.

\end{itemize}

Please note that some files are omitted here due to limited space.

\newpage

\section{Model, Command, Keymap, and Action}
\elmtt{Model} is defined in \texttt{src/Models/Model.elm} as the following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias Model =
  { config       : Config
  , root_package : Package
  , root_keymap  : Keymap
  , grids        : Grids
  , pane_cursor  : PaneCursor
  , mode         : Mode
  , message_list : MessageList
  , environment  : Environment
  }
\end{lstlisting}
\end{framed}
\caption{Declaration of \elmtt{Model}}
\label{fig:implementation-model}
\end{figure}

A function that can manipulate \elmtt{Model} has type signature as
\begin{lstlisting}[language=elm]
type alias Command = Model -> Model
\end{lstlisting}

\elmtt{Action} is defined in \texttt{src/Models/Action.elm}
as the following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type Action
  = ActionNothing
  | ActionCommand Command
  | ActionKeystroke Keystroke
\end{lstlisting}
\end{framed}
\caption{Declaration of \elmtt{Action}}
\label{fig:implementation-action}
\end{figure}

One way to interact with Phometa is to click some button (or any clickable
area), when this is clicked, it will update the value of \elmtt{action_signal}
to ``\elmtt{ActionCommand cmd}'' where \elmtt{cmd} is an instance of
\elmtt{Command} injected to that button earlier.

\elmtt{Signal.foldp} will detect change in \elmtt{action_signal} so it applies
function \elmtt{update} with ``\elmtt{ActionCommand cmd}'' to
\elmtt{model_signal}. The function \elmtt{update}, in tern, will apply command
\elmtt{cmd} to current model and this is how model can be updated.

Again, \elmtt{Signal.map} will detect change in \elmtt{action_model} so it
applies function \elmtt{view} with current model to get latest HTML instance,
please note that \elmtt{view} might inject further commands to buttons, if
user click any button, then the entire process will happen again.

Another way to interact with Phometa is to press some keystroke, this will make
\elmtt{action_signal} changes to ``\elmtt{ActionKeystroke keystroke}'', where
\elmtt{keystroke} is a \elmtt{List} of \elmtt{KeyCode} obtained from
\elmtt{Keyboard.keysDown}.

\elmtt{Signal.foldp} will detect change in \elmtt{action_signal} so it applies
function \elmtt{update} with ``\elmtt{ActionKeystroke keystroke}'' to
\elmtt{model_signal}. The function \elmtt{update}, in tern, will search a
command that corresponded to this keystroke from \elmtt{model.root_keymap} to
apply such a command with current model. Now, the remaining process is the same
as when we click button.

% \section{Modes}
% Phometa as several internal modes to deal with non-global key-blindings as are
% in keymap pane. For example if user is inputting a term, there will be
% key-blindings that allow user to select several choices, if user click somewhere
% else, these key-blindings will be replaced by new key-blindings of corresponded
% mode.

% \elmtt{Mode} is defined in \texttt{src/Models/Model.elm} as the following

% \begin{figure}[H]
% \begin{framed}
% \begin{lstlisting}[language=elm]
% type Mode
%   = ModeNothing
%   | ModeMenu
%   | ModeRepo RecordModeRepo
%   | ModeModule RecordModeModule
%   | ModeComment RecordModeComment
%   | ModeGrammar RecordModeGrammar
%   | ModeRootTerm RecordModeRootTerm
%   | ModeRule RecordModeRule
%   | ModeTheorem RecordModeTheorem
% \end{lstlisting}
% \end{framed}
% \caption{Declaration of \elmtt{Mode}}
% \label{fig:implementation-mode}
% \end{figure}

% It is defined
% The main usage of mode TODO:

% \elmtt{model.mode}

\section{Structure of Proofs Repository}
In this section, we will show the complete internal representation of a proofs
repository. All codes inside this section come from
\texttt{src/Models/RepoModel.elm}

Let define some common elements first\footnote{\elmtt{Arguments} depends on
  \elmtt{RootTerm} which will be defined later in this section}.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias ContainerName = String
type alias ContainerPath = List ContainerName
type alias Format = String
type alias VarName = String
type alias Parameters = List { grammar  : GrammarName
                             , var_name : VarName }
type alias Arguments = List RootTerm
\end{lstlisting}
\end{framed}
\caption{Representation of common elements that will be used later on}
\label{fig:implementation-repo-common}
\end{figure}

Now, we can define a proof repository which is just a big \elmtt{Package} stored
in global model named \elmtt{model.root\_package} and can be defined as the
following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias PackageName = ContainerName
type alias PackagePath = List PackageName
type alias Package = { is_folded : Bool
                     , dict : Dict ContainerName PackageElem }
type PackageElem
  = PackageElemPkg Package
  | PackageElemMod Module
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Package} and related components.}
\label{fig:implementation-repo-package}
\end{figure}

We could think a \elmtt{Package} roughly as a collection containing other
\elmtt{Package}s and \elmtt{Module}s. We also need \elmtt{PackagePath} to
reference a package relatively to root package.

\elmtt{Module} is a collection containing nodes. \elmtt{ModulePath} is a
unique reference from root package to this module.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias ModuleName = ContainerName
type alias ModulePath = { package_path : PackagePath
                        , module_name  : ModuleName }
type alias Module = { is_folded : Bool
                    , nodes     : OrderedDict NodeName Node }
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Module} and related components.}
\label{fig:implementation-repo-module}
\end{figure}

There are four types of \elmtt{Node} which are \elmtt{Comment}, \elmtt{Grammar},
\elmtt{Rule}, and \elmtt{Theorem}\footnote{\elmtt{Bool} that follows
  \elmtt{NodeTheorem} tells whether that theorem has been converted to lemma or
  not}. \elmtt{NodePath} is a unique reference from root package to this
node.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias NodeName = ContainerName

type alias NodePath =
  { module_path : ModulePath
  , node_name   : NodeName
  }

type Node
  = NodeComment String
  | NodeGrammar Grammar
  | NodeRule Rule
  | NodeTheorem Theorem Bool -- Bool = has_locked

type NodeType
  = NodeTypeComment
  | NodeTypeGrammar
  | NodeTypeRule
  | NodeTypeTheorem
\end{lstlisting}
% type alias NodeName = ContainerName
% type alias NodePath = { module_path : ModulePath
%                       , node_name   : NodeName }
% type Node = NodeComment String
%           | NodeGrammar Grammar
%           | NodeRule Rule
%           | NodeTheorem Theorem Bool
% type NodeType = NodeTypeComment
%               | NodeTypeGrammar
%               | NodeTypeRule
%               | NodeTypeTheorem
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Node} and related components.}
\label{fig:implementation-repo-node}
\end{figure}

We could define \elmtt{Grammar} as the following,

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias GrammarName = String

type alias Grammar =
  { is_folded     : Bool
  , has_locked    : Bool
  , metavar_regex : Maybe Regex
  , literal_regex : Maybe Regex
  , choices       : List GrammarChoice
  }

type alias GrammarChoice = StripedList Format GrammarName
\end{lstlisting}
% type alias GrammarName = String
% type alias Grammar = { is_folded     : Bool
%                      , has_locked    : Bool
%                      , metavar_regex : Maybe Regex
%                      , literal_regex : Maybe Regex
%                      , choices       : List GrammarChoice }
% type alias GrammarChoice = StripedList Format GrammarName
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Grammar} and related components.}
\label{fig:implementation-repo-grammar}
\end{figure}

\elmtt{StripedList Format GrammarName} is just a pair of ``list of
\elmtt{Format}'' and ``list of \elmtt{GrammarName}'' but it also ensure that
length of ``list of \elmtt{Format}'' is longer than ``list of
\elmtt{GrammarName}'' by exactly 1.

Next is a term, which can be defined like this,

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type Term
  = TermTodo
  | TermVar VarName
  | TermInd GrammarChoice (List Term)

type alias RootTerm =
  { grammar : GrammarName
  , term : Term
  }

type VarType
  = VarTypeMetaVar
  | VarTypeLiteral
\end{lstlisting}
% type Term = TermTodo
%           | TermVar VarName
%           | TermInd GrammarChoice (List Term)
% type alias RootTerm = { grammar : GrammarName
%                       , term : Term }
% type VarType = VarTypeMetaVar
%              | VarTypeLiteral
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Term} and related components.}
\label{fig:implementation-repo-term}
\end{figure}

We usually use \elmtt{RootTerm} as a term at the top level, this is because it
know its known grammar. In fact, \elmtt{Term} is just an auxiliary model of
\elmtt{RootTerm}. Please note that it is possible to fine the grammar of every
sub-term of a \elmtt{RootTerm}, because we can refer to \elmtt{grammar}
property of \elmtt{RootTerm} for top level and refer to \elmtt{GrammarChoice}
of \elmtt{TermInd} for deeper sub-term.

Once \elmtt{RootTerm} has been defined, we can define \elmtt{Rule} and
\elmtt{Theorem} as the following,

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias RuleName = String

type alias Rule =
  { is_folded       : Bool
  , has_locked      : Bool
  , allow_reduction : Bool
  , parameters      : Parameters
  , conclusion      : RootTerm
  , premises        : List Premise
  }

type Premise
  = PremiseDirect RootTerm
  | PremiseCascade (List PremiseCascadeRecord)

type alias PremiseCascadeRecord =
  { rule_name : RuleName
  , pattern : RootTerm
  , arguments : Arguments
  , allow_unification : Bool
  }
\end{lstlisting}

% type alias RuleName = String
% type alias Rule = { is_folded       : Bool
%                   , has_locked      : Bool
%                   , allow_reduction : Bool
%                   , parameters      : Parameters
%                   , conclusion      : RootTerm
%                   , premises        : List Premise }
% type Premise = PremiseDirect RootTerm
%              | PremiseCascade (List PremiseCascadeRecord)
% type alias PremiseCascadeRecord = { rule_name : RuleName
%                                   , pattern : RootTerm
%                                   , arguments : Arguments
%                                   , allow_unification : Bool }
% \end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Rule} and related components.}
\label{fig:implementation-repo-rule}
\end{figure}


\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias TheoremName = String

type alias Theorem =
  { is_folded : Bool
  , goal      : RootTerm
  , proof     : Proof
  }

type Proof
  = ProofTodo
  | ProofTodoWithRule RuleName Arguments
  | ProofByRule RuleName Arguments PatternMatchingInfo
      (List Theorem)
  | ProofByLemma TheoremName PatternMatchingInfo
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{Theorem} and related components.}
\label{fig:implementation-repo-theorem}
\end{figure}

\elmtt{PatternMatchingInfo} is a result when a pattern matching is successful
and can be defined as the following,


\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
type alias SubstitutionList =
  List { old_var : VarName
       , new_root_term : RootTerm
       }

type alias PatternMatchingInfo =
  { pattern_variables : Dict VarName RootTerm
  , substitution_list : SubstitutionList
  }
\end{lstlisting}
\end{framed}
\caption{Representation of \elmtt{PatternMatchingInfo} and related components.}
\label{fig:implementation-repo-pattern-matching-info}
\end{figure}

As we know that terms that match to the same pattern variable will be unified
during matching, \elmtt{SubstitutionList} tell us that what meta-variables
(\elmtt{old\_var}) should be replaced \elmtt{new\_root\_term}. The order of
substitution is important as later substitution might depend on earlier one. Now
we can guarantee that, after unification, each pattern variable will match to
only one term, this make it possible to create a dictionary
\elmtt{pattern\_variables} that map these pattern variables to the corresponded
terms.

\section{Samples of code --- Pattern Matching}
Although it is impossible to show all of codes written for Phometa, but there is
a faction of code related to \emph{Pattern Matching} that is small to be shown
entirely, it is one of the most interesting part as well. All codes inside this
section come from \texttt{src/Models/RepoUtils.elm}.

Let start with the most important, \elmtt{pattern\_match} is a function that
pattern match \elmtt{pattern} against \elmtt{target}, if success, it will the
return pattern matching information as described in previous section. Another
function is \elmtt{pattern\_match\_multiple} which is the same as previous
function but and receive list of pair of \elmtt{(pattern, target)}

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
pattern_match : ModulePath -> Model -> RootTerm -> RootTerm
                  -> Maybe PatternMatchingInfo
pattern_match module_path model pattern target =
  pattern_match_get_vars_dict pattern target
    |> (flip Maybe.andThen)
         (vars_dict_to_pattern_matching_info module_path model)

pattern_match_multiple : ModulePath -> Model
                           -> List (RootTerm, RootTerm)
                           -> Maybe PatternMatchingInfo
pattern_match_multiple module_path model list =
  let vars_dict_maybe_list =
        List.map (uncurry pattern_match_get_vars_dict) list
   in if List.any ((==) Nothing) vars_dict_maybe_list then
        Nothing
      else
        vars_dict_maybe_list
          |> List.filterMap identity
          |> merge_pattern_variables_list
          |> vars_dict_to_pattern_matching_info
               module_path model
\end{lstlisting}
\end{framed}
\caption{Functions \elmtt{pattern\_match} and \elmtt{pattern\_match\_multiple}.}
\label{fig:implementation-repo-pattern-matching-info}
\end{figure}

Both of functions above call function \elmtt{pattern\_match\_get\_vars\_dict} that
perform the actual pattern matching and return a dictionary that map each
pattern variable to a list of terms. The the pattern match process can be
described as the following
\begin{itemize}
\item If the grammar of pattern and target is not the same, fail immediately.
\item If any of pattern or target is unfinished term, fail immediately.
\item If pattern is a variable, success immediately with that variable
  map to the target.
\item If target is a variable but pattern is not, fail immediately, this is
  one way matching.
\item the only possibility left is both of them are
  \elmtt{TermInd}\footnote{A term can be either unfinished, variable, or
    \elmtt{TermInd}}, so it can process as the following
  \begin{itemize}
  \item If the grammar choice of pattern and target is not the same, fail
    immediately.
  \item Otherwise, recursively call current function on their sub terms,
    \begin{itemize}
      \item If any of sub-term fail pattern matching, then the entire function fail.
      \item Otherwise, merge these sub-result together and successfully return it.
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
pattern_match_get_vars_dict : RootTerm -> RootTerm ->
                       Maybe (Dict VarName (List RootTerm))
pattern_match_get_vars_dict pattern target =
  if pattern.grammar /= target.grammar then Nothing else
  case (pattern.term, target.term) of
    (TermTodo, $\mathunderscore$) -> Nothing
    ($\mathunderscore$, TermTodo) -> Nothing
    (TermVar var_name, $\mathunderscore$) -> Just (Dict.singleton
                                    var_name [target])
    ($\mathunderscore$, TermVar $\mathunderscore$) -> Nothing
    (TermInd pat_mixfix pat_sub_terms,
        TermInd tar_mixfix tar_sub_terms) ->
      if pat_mixfix /= tar_mixfix then Nothing else
        let maybe_result_list = List.map2
              pattern_match_get_vars_dict
              (get_sub_root_terms pat_mixfix pat_sub_terms)
              (get_sub_root_terms tar_mixfix tar_sub_terms)
         in if List.any ((==) Nothing) maybe_result_list then
              Nothing
            else
              maybe_result_list
                |> List.filterMap identity
                |> merge_pattern_variables_list
                |> Just
\end{lstlisting}
\end{framed}
\caption{Function \elmtt{pattern\_match\_get\_vars\_dict}.}
\end{figure}

After \elmtt{pattern\_match\_get\_vars\_dict} produces matching dictionary. \\
\elmtt{vars\_dict\_to\_pattern\_matching\_info} will try to fit this into
\elmtt{PatternMatchingInfo}. This can be done by finding a
\elmtt{SubstitutionList} that can eliminate all of ambiguity among terms which
are the value of matching dictionary. This \elmtt{SubstitutionList} can be found
by using the following method.
\begin{itemize}
\item For each pattern variable, check whether it is meta variable or literal.
\item If it is meta variable, unify corresponded terms to each other then append
  these unification result to the main \elmtt{SubstitutionList}.
\item If it is literal, check that each of term is that exact variable as well,
  otherwise, fail.
\end{itemize}

Then we can substitute this \elmtt{SubstitutionList} to the matching directly to
get \elmtt{pattern\_variables}, hence be able to return
\elmtt{PatternMatchingInfo} as expected.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm,basicstyle=\footnotesize\ttfamily]
vars_dict_to_pattern_matching_info : ModulePath -> Model
                                       -> Dict VarName (List RootTerm)
                                       -> Maybe PatternMatchingInfo
vars_dict_to_pattern_matching_info module_path model vars_dict =
  let subst_list_func var_name root_term_list maybe_acc_subst_list =
        let grammar_name = (.grammar) (list_get_elem 0 root_term_list)
         in case get_variable_type module_path model
                var_name grammar_name of
              Nothing             -> Nothing
              Just VarTypeMetaVar -> case root_term_list of
                []              -> Nothing
                root_term :: [] -> maybe_acc_subst_list
                fst_root_term :: other_root_terms ->
                  let fold_func root_term maybe_acc =
                    let maybe_partial_subst_list =
                      Maybe.andThen maybe_acc (\acc ->
                       unify module_path model
                        (multiple_root_substitute acc fst_root_term)
                        (multiple_root_substitute acc root_term))
                     in Maybe.map2 (++) maybe_acc
                          maybe_partial_subst_list
                   in List.foldl fold_func
                        maybe_acc_subst_list other_root_terms
              Just VarTypeLiteral ->
                if List.all ((==) ({ grammar = grammar_name
                                   , term = TermVar var_name
                                   })) root_term_list
                  then maybe_acc_subst_list else Nothing
      maybe_subst_list = Dict.foldl subst_list_func
                           (Just []) vars_dict
   in Maybe.map (\subst_list ->
        { pattern_variables =
            Dict.map (\var_name root_term_list ->
              multiple_root_substitute subst_list <|
                list_get_elem 0 root_term_list) vars_dict
        , substitution_list = subst_list
        }) maybe_subst_list
\end{lstlisting}
\end{framed}
\caption{Function \elmtt{vars\_dict\_to\_pattern\_matching\_info}.}
\end{figure}

Function \elmtt{unify} receives term \elmtt{a} and \elmtt{b} then try to build
most general unifier (mgu) which is the most general substitution list that is
specific enough to make term \elmtt{a} and \elmtt{b} identical.

Unification process is similar to pattern matching in
\elmtt{pattern\_match\_get\_vars\_dict} but this is this is two wat matching and
it is aware whether a variable is meta variable or literal.

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm,basicstyle=\footnotesize\ttfamily]
unify : ModulePath -> Model -> RootTerm -> RootTerm
          -> Maybe (SubstitutionList)
unify module_path model a b =
  if a.grammar /= b.grammar then Nothing else
  case (a.term, b.term) of
    (TermTodo, $\mathunderscore$) -> Nothing
    ($\mathunderscore$, TermTodo) -> Nothing
    (TermVar a_var_name, $\mathunderscore$) ->
      case get_variable_type module_path model a_var_name a.grammar of
        Nothing -> Nothing
        Just VarTypeMetaVar -> Just ([{ old_var = a_var_name
                                      , new_root_term = b}])
        Just VarTypeLiteral -> case b.term of
          TermVar b_var_name ->
            case get_variable_type module_path model
                   b_var_name b.grammar of
              Nothing -> Nothing
              Just VarTypeMetaVar -> Just ([{ old_var = b_var_name
                                            , new_root_term = a}])
              Just VarTypeLiteral -> if a_var_name == b_var_name
                                       then Just [] else Nothing
          $\mathunderscore$                  -> Nothing
    ($\mathunderscore$, TermVar b_var_name) ->
      case get_variable_type module_path model b_var_name b.grammar of
        Nothing -> Nothing
        Just VarTypeMetaVar -> Just ([{ old_var = b_var_name
                                      , new_root_term = a}])
        Just VarTypeLiteral -> Nothing
    (TermInd a_mixfix a_sub_terms, TermInd b_mixfix b_sub_terms) ->
      if a_mixfix /= b_mixfix then Nothing else
        let fold_func (a_root_sub_term, b_root_sub_term)
                maybe_acc_subst_list =
              let maybe_partial_subst_list =
                    Maybe.andThen maybe_acc_subst_list
                      (\subst_list -> unify module_path model
                         (multiple_root_substitute
                           subst_list a_root_sub_term)
                         (multiple_root_substitute
                           subst_list b_root_sub_term))
               in Maybe.map2 List.append maybe_acc_subst_list
                                         maybe_partial_subst_list
         in List.foldl fold_func (Just []) <|
              List.map2 (,) (get_sub_root_terms a_mixfix a_sub_terms)
                            (get_sub_root_terms b_mixfix b_sub_terms)
\end{lstlisting}
\end{framed}
\caption{Function \elmtt{unify}.}
\end{figure}

Lastly, we can implement the remaining auxiliary functions of pattern matching
as the following,

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm,basicstyle=\scriptsize\ttfamily]
substitute : VarName -> Term -> Term -> Term
substitute old_var new_term top_term =
  case top_term of
    TermTodo -> TermTodo
    TermVar var_name -> if var_name == old_var
                          then new_term else TermVar var_name
    TermInd grammar_choice sub_terms ->
      TermInd grammar_choice <|
        List.map (substitute old_var new_term) sub_terms

multiple_root_substitute : SubstitutionList -> RootTerm -> RootTerm
multiple_root_substitute list top_root_term =
  let fold_func record acc =
        substitute record.old_var record.new_root_term.term acc
      update_func top_term = List.foldl fold_func top_term list
   in Focus.update term_ update_func top_root_term

pattern_substitute : Dict VarName RootTerm -> Term -> Term
pattern_substitute dict top_term =
  case top_term of
    TermTodo -> TermTodo
    TermVar var_name -> case Dict.get var_name dict of
                          Nothing            -> TermVar var_name
                          Just new_root_term -> new_root_term.term
    TermInd grammar_choice sub_terms ->
      TermInd grammar_choice <|
        List.map (pattern_substitute dict) sub_terms

pattern_root_substitute : Dict VarName RootTerm -> RootTerm -> RootTerm
pattern_root_substitute dict top_root_term =
  Focus.update term_ (pattern_substitute dict) top_root_term

pattern_matching_info_substitute : PatternMatchingInfo -> SubstitutionList
                                     -> PatternMatchingInfo
pattern_matching_info_substitute pm_info substitution_list =
  { pattern_variables = Dict.map (\ $\mathunderscore$ ->
      multiple_root_substitute substitution_list) pm_info.pattern_variables
  , substitution_list = List.append pm_info.substitution_list
                          substitution_list }

pattern_matchable : ModulePath -> Model -> RootTerm -> RootTerm -> Bool
pattern_matchable module_path model pattern target =
  pattern_match module_path model pattern target /= Nothing

merge_pattern_variables_list : List (Dict VarName (List RootTerm)) ->
                                 Dict VarName (List RootTerm)
merge_pattern_variables_list main_list =
  let dict_fold_func key target_val acc =
        let old_val = Maybe.withDefault [] (Dict.get key acc)
            new_val = List.append target_val old_val
         in Dict.insert key new_val acc
      list_fold_func dict acc = Dict.foldl dict_fold_func dict acc
   in List.foldl list_fold_func Dict.empty main_list
       |> Dict.map (\ $\mathunderscore$ list -> list_remove_duplication list)
\end{lstlisting}
\end{framed}
\caption{Other auxiliary functions for pattern matching.}
\end{figure}


\section{Building a Complied Version}
We can build the complied version of Phometa by go to the top directory of
Phometa repository then execute \texttt{./scripts/build.sh}. This will process
as the following
\begin{itemize}
\item create \texttt{build/} (if doesn't exist) or clean it (if doesn't empty)
\item compile(\LaTeX) the document in \texttt{doc/} and copy the main PDF file to \texttt{build/}
\item compile(Sass) \texttt{src/style.scss} to \texttt{build/style.css}
\item copy the following files to \texttt{build/}
  \begin{itemize}
  \item \texttt{src/naive.js}
  \item \texttt{src/repository.json}
  \item \texttt{src/phometa-server.py}
  \item \texttt{logo.png}
  \end{itemize}
\item compile(Elm) \texttt{src/Main.elm} to \texttt{build/phometa.html}
\item compress everything in \texttt{build/} to \texttt{build/phometa.tar.gz}
\end{itemize}

Please note that Elm compilation will consult \texttt{elm-package.json} for meta
data. The dependency of target Elm file will be complied recursively. It can be
outputted as HTML file (for standalone application) or JavaScript file (to
embedded it as an element of bigger application).

\section{Back-End Communication}
There is a python server template from
\url{https://gist.github.com/UniIsland/3346170} which allows client to
download and upload local files directly in the server.

This server template, with some modification, allows us to create a local server
to serve \texttt{phometa.html} which is the main application that user will
interact with. \texttt{phometa.html}, in tern, will load further resource such
as \texttt{naive.js} (for naive code that can't be done directly in Elm) and
\texttt{style.css} (for theme of Phometa).

Once the setup is completed, Phometa will automatically load the repository by
sending Ajax request to load \texttt{repository.json} from the server, and then,
it will decode this json file to get instance of \elmtt{Package} and will set
this to \elmtt{model.root_package}.

Most of operation after this doesn't require further communication with the
server. Nevertheless, if user would like to save the repository, Phometa will
encode \elmtt{model.root_package} and send Ajax request to upload this as
\texttt{repository.json}.

\section{Testing / Continious Integration}
Functional programming makes testing really easy. In order to test a function,
we need to create a test suite and call that function with several inputs then
check whether the outputs are the same as expectation or not.

For example, we want to test a function \elmtt{list\_insert} as the following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
list_insert : Int -> a -> List a -> List a
list_insert n x xs =
  if n <= 0 then x :: xs else
    case xs of
      []      -> [x]
      y :: ys -> y :: (list_insert (n - 1) x ys)
\end{lstlisting}
\end{framed}
\caption{Function \elmtt{list\_insert} from \texttt{src/Tools/Utils.elm}}
\label{fig:implementation-test-src}
\end{figure}

We could write a test suite for \elmtt{list\_insert} in the test suite of its module like this

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
module Tests.Tools.Utils where

import ElmTest exposing (Test, test, suite, assert,
                         assertEqual, assertNotEqual)
import Tools.Utils exposing (..)

tests : Test
tests = suite "Tools.Utils" [
  suite "list_skeleton" [...],
  suite "list_insert" [
    test "n < 0" <|
      assertEqual [7, 6, 4, 9] (list_insert (-1) 7 [6, 4, 9]),
    test "n = 0" <|
      assertEqual [7, 6, 4, 9] (list_insert 0 7 [6, 4, 9]),
    test "n in range" <|
      assertEqual [6, 4, 7, 9] (list_insert 2 7 [6, 4, 9]),
    test "n >= length" <|
      assertEqual [6, 4, 9, 7] (list_insert 10 7 [6, 4, 9]),
    ... ],
  suite "parity_pair_extract" [...],
  suite "remove_list_duplicate" [...],
  ... ]
\end{lstlisting}
\end{framed}
\caption{The test suite for module \texttt{src/Tools/Utils.elm}}
\label{fig:implementation-test-test}
\end{figure}

A test suite of each module will be included in the main test suite as the
following

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[language=elm]
module Main where

import Task
import Console exposing (run)
import ElmTest exposing (Test, suite, consoleRunner)

...
import Tests.Tools.Utils
...

tests : Test
tests = suite "Tests" [ ... , Tests.Tools.Utils.tests, ... ]

port runner : Signal (Task.Task x ())
port runner = run (consoleRunner tests)
\end{lstlisting}
\end{framed}
\caption{The main test suite which is at \texttt{tests/Tests/Main.elm}}
\label{fig:implementation-test-main}
\end{figure}

To run the main test suite, go to top level of Phometa repository\\ then execute
\texttt{./scripts/tests.sh} which will be processed as the following.
\begin{itemize}
\item compile \texttt{tests/Tests/Main.elm} to \texttt{raw-tests.js}
\item convert \texttt{raw-tests.js} to \texttt{tests.js} using external bash
  script\footnote{\url{https://raw.githubusercontent.com/laszlopandy/elm-console/master/elm-io.sh}}.
\item execute \texttt{tests.js} by \emph{Node.js}, this will show the testing result.
\end{itemize}

Please note that the test suite doesn't have 100\% coverage and functions
related to HTML are not testable using this method.

\emph{Travis CI} is used for continuous integration. Basically, every time when
something is pushed to \emph{GitHub}, Travis CI will check \texttt{.travis.yml}
this will result in the main test suite being executed in virtual machine using
similar testing process above.


\end{document}