\documentclass[master.tex]{subfiles}
\begin{document}

\chapter{Example Formal System --- Propositional Logic}
\label{chap:example_propositional_logic}

Once you are familiar with some basic features and usability of \emph{Phometa}
from the last chapter. This chapter aims to show more advance features on
another formal system named \emph{Propositional Logic} which is the most well
known logical system\footnote{Logical system is a formal system together with
  semantics\supercite{formal-system-wiki}}.

Logic, in general, works so well with traditional derivation system, hence there
is spacial name called \emph{Natural Deduction} which is a combination of any
kind of Logic together with derivation system.

\section{Grammars}

As usual, the first thing that needed to be defined grammars. Propositional
Logic has 4 grammars which are \pgmr{Prop}, \pgmr{Atom},
\pgmr{Context}, and \pgmr{Judgement} as its grammars.

\pgmr{Prop} is a proposition, semantically, it is a term that can be evaluated
to either true or false (given that there are no meta variables in the term).
Grammars of \pgmr{Prop} can be defined in Phometa as the following

\begin{figure}[H]
    \centering
\begin{minipage}{0.7\textwidth}
    \includegraphics[width=\textwidth]{prop-grammar-prop}
\end{minipage}
\caption{Definition of \pgmr{Prop}}
\label{fig:prop-grammar-prop}
\end{figure}

This grammar is equivalence to the following Backus Normal Form

\begin{figure}[H]
\begin{framed}
\begin{lstlisting}[style=bnf]
<Prop> ::= $\top$ | $\bot$ | <Atom>
         | <Prop> $\wedge$ <Prop>
         | <Prop> $\vee$ <Prop>
         | $\neg$ <Prop>
         | <Prop> $\rightarrow$ <Prop>
         | <Prop> $\leftrightarrow$ <Prop>
         | meta-variables comply with regex
             /[A-Z][a-zA-Z]*([1-9][0-9]*|'*)/
\end{lstlisting}
\end{framed}
\caption{Backus-Naur Form correspond to \pgmr{Prop}}
\label{fig:prop-bnf-prop}
\end{figure}

\newcommand{\propTop}[0]{\bat{\pifmt{$\top$}}}
\newcommand{\propBot}[0]{\bat{\pifmt{$\bot$}}}
\newcommand{\propAnd}[0]{\pifmt{$\wedge$}}
\newcommand{\propOr}[0]{\pifmt{$\vee$}}
\newcommand{\propNot}[0]{\pifmt{$\neg$}}
\newcommand{\propImp}[0]{\pifmt{$\rightarrow$}}
\newcommand{\propIff}[0]{\pifmt{$\leftrightarrow$}}

On the $3^{rd}$ choice of \pgmr{Prop} depends on \pgmr{Atom} which represents
primitive truth statement that cannot be broken down any further. It can be
defined in Phometa as the following.

\begin{figure}[H]
    \centering
\begin{minipage}{0.7\textwidth}
    \includegraphics[width=\textwidth]{prop-grammar-atom}
\end{minipage}
\caption{Definition of \pgmr{Atom}}
\label{fig:prop-grammar-atom}
\end{figure}

You can see that \kLiteralRegex\ appears inside \pgmr{Atom} definition, this
allows \pgmr{Atom} be instantiated by literal which is similar to meta variable,
the only different is that literal doesn't have ability to be substituted by
arbitrary term like meta variable.

At this stage, you might wonder that why \pgmr{Prop} needs both of meta
variables and \pgmr{Atom}. Well, meta variable will be used when referring to
something general and \pgmr{Atom} will used when referring to particular truth
statement. For example, if we can prove that \term{prop-term-lem-big-a} is
valid, then terms such as \term{prop-term-lem-top},
\term{prop-term-lem-top-imply-bot}, \term{prop-term-lem-big-b},
\term{prop-term-lem-rainning}, and \term{prop-term-lem-big-b-and-rainning} are
also valid. However, if we can prove that \term{prop-term-lem-rainning} is
valid, we don't want to expose this proof to other terms since it might be
proven from specific knowledge.

Now, we have enough ingredient to create a proper proposition, one might say
that we can start proving it directly, however, most of proposition that we will
dealing with only holds under certain assumptions, hence, a \emph{judgement}
should be in the form $A_1, A_2, ..., A_n \vdash B$ where $A_{1..n}$ are
assumptions and $B$ is conclusion.

To model a judgement in Phometa, first we need to model assumptions or in the
other name, \pgmr{Context} as the following

\begin{figure}[H]
    \centering
\begin{minipage}{0.7\textwidth}
    \includegraphics[width=\textwidth]{prop-grammar-context}
\end{minipage}
\caption{Definition of \pgmr{Context}}
\label{fig:prop-grammar-context}
\end{figure}

\newcommand{\propEmptyContext}{\bat{\pifmt{$\epsilon$}}}

So a term of \pgmr{Context} can be either empty context or another context
appended by a proposition. We can see a context as a list of proposition.

Now we are ready to define \pgmr{Judgement} as the following

\begin{figure}[H]
    \centering
\begin{minipage}{0.7\textwidth}
    \includegraphics[width=\textwidth]{prop-grammar-judgement}
\end{minipage}
\caption{Definition of \pgmr{Judgement}}
\label{fig:prop-grammar-judgement}
\end{figure}

\newcommand{\propTurnstile}{\pifmt{$\vdash$}}

\pgmr{Judgement} has a meaning of validity. For example, validity of
\term{prop-judgement-ex-1} means, assuming that \term{prop-judgement-ex-1-1} and
\term{prop-judgement-ex-1-2} hold then \term{prop-judgement-ex-1-3} holds.

Please note that \pgmr{Judgement} doesn't have field \kMetaVarRegex nor
\kLiteralRegex \ so we can't accidentally use meta variable or literal for
\pgmr{Judgement}.

\section{Hypothesis rules}

In order to prove any judgement, we want ability to state that for any
proposition that is in assumptions, it can be conclusion i.e. $A_{1..n} \vdash
A_i$ where $i \in {1..n}$

This is achievable by \prule{hypothesis-base} and \prule{hypothesis-next}.

\begin{center}
\includegraphics[scale=0.5]{prop-rule-hypo-base}
\end{center}
\begin{center}
\includegraphics[scale=0.5]{prop-rule-hypo-next}
\end{center}

\prule{hypothesis-base} matches the last assumption with the conclusion whereas
\prule{hypothesis-next} removes the last assumption and pass on to a premise,
this can prove a judgement that has conclusion as assumption like this.

\begin{center}
\includegraphics[scale=0.5]{prop-tut-hypo-1}
\end{center}

This is not efficient as we might need to call \prule{hypothesis-next} $(n - 1)$
times where n is the number of assumptions. To solve this problem, we introduce
 \prule{hypothesis} that is more complex than ordinary derivation rule.


\begin{figure}[H]
\begin{minipage}{\textwidth}
    \centering
\includegraphics[scale=0.5]{prop-rule-hypo}
\end{minipage}
    \caption{rule \prule{Hypothesis}}
\label{fig:prop-rule-hypothesis}
\end{figure}

\prule{hypothesis} uses a cascade premise instead of direct premise. A cascade
premise has several sub-rules calling-template that will be tried in order. In
this case, \prule{hypothesis} tries to apply \prule{hypothesis-base} on its
goal,
\begin{itemize}
\item If sub-rule is applicable, then use sub-goals generated from sub-rule as
  its sub-goals, in this case, \prule{hypothesis-base} doesn't have any premises
  so this cascade premise has no further sub-goals.
\item Otherwise, \emph{cascade}s down and tries to apply the next sub-rule which
  is \prule{hypothesis} itself\footnote{Yes, it supports recursive call}. Again,
  if applicable, use sub-goals of sub-rule, otherwise, the main
  \prule{hypothesis} rule fail as the cascade premise fail to match with any
  ofsub-rules.
\end{itemize}

\prule{hypothesis} could solve the last theorem like this

\begin{center}
\includegraphics[scale=0.5]{prop-tut-hypo-2}
\end{center}

To show the process, first \prule{hypothesis} conclusion ---
\term{prop-tut-hypo-4} is pattern match against goal = \term{prop-tut-hypo-3},
this results in \pvar{A} = \term{prop-tut-hypo-5}, \pvar{B} =
\term{prop-tut-hypo-6}, and \pvar{$\Gamma$} = \term{prop-tut-hypo-7}. This
cascade premise try to apply \prule{hypothesis-base} with goal\footnote{This is
  result from substitution to that sub-rule goal template. Coincidentally, it is
  the same as \prule{hypothesis} conclusion} = \term{prop-tut-hypo-3}.

\prule{hypothesis-base}, as sub-rule, let \term{prop-tut-hypo-8} pattern match
against \term{prop-tut-hypo-3} and get \pvar{A} = \term{prop-tut-hypo-5},
\pvar{A} = \term{prop-tut-hypo-6}, and \pvar{$\Gamma$} = \term{prop-tut-hypo-7}.
When a meta variable is matched with two or more terms, those terms will be
unified to make pattern match still possible. So \term{prop-tut-hypo-6} will be
replaced by \term{prop-tut-hypo-5} and this sub-rule will success. Here is the
same result if \prule{hypothesis-base} is applied directly on the theorem.

\begin{center}
\includegraphics[scale=0.5]{prop-tut-hypo-9}
\end{center}

However, this is not what we want, to avoid this problem, we cat put flag
\kExactMatch\ to this sub-rule, this flag will prevent further unification. Now,
\term{prop-tut-hypo-6} cannot unify with \term{prop-tut-hypo-5} so this sub-rule
fail. So, the cascade premise will move to second sub-rule and try to apply
\prule{hypothesis} with \term{prop-tut-hypo-10}.

\prule{hypothesis}, as sub-rule, let \term{prop-tut-hypo-4} pattern match
against \term{prop-tut-hypo-10}, the process is similar as before so I can tell
directly that it will apply \prule{hypothesis} as sub-sub-rule with goal =
\term{prop-tut-hypo-11}, which in tern, apply \prule{hypothesis} as
sub-sub-sub-rule with goal = \term{prop-tut-hypo-12}.

Now, \prule{hypothesis-base} with goal = \term{prop-tut-hypo-12} will not fail
again since the last assumption and the conclusion is exactly match, i.e. no
further unification needed hence it will success and return no sub-goals as
\prule{hypothesis-base} doesn't have any. This success will propagate up to the
top level and the entire will cascade success with no further sub-goals as shown
in \pthm{tutorial-hypothesis-2}.

Please note that a cascade premise is just another type of a premise, sub-goals
that are generated from sub-rule will replace the cascade premise itself,
similar to how a sub-goal replaces direct premise. Thus, cascade premise can be
used alongside with direct premises, for more information on cascade blocks
please see \hyperref[chap:specification]{specification chapter}.

\hspace{2ex}

\section{Main Rules}

Now, Propositional Logic is ready for new rules as the following,

\begin{figure}[H]
    \centering

\begin{minipage}{0.48\textwidth}
\begin{flushleft}
\includegraphics[width=\textwidth]{prop-rule-the-rest-1}
\includegraphics[width=\textwidth]{prop-rule-the-rest-2}
\includegraphics[width=\textwidth]{prop-rule-the-rest-3}
\includegraphics[width=\textwidth]{prop-rule-the-rest-4}
\includegraphics[width=\textwidth]{prop-rule-the-rest-5}
\includegraphics[width=\textwidth]{prop-rule-the-rest-6}
\includegraphics[width=\textwidth]{prop-rule-the-rest-7}
\includegraphics[width=\textwidth]{prop-rule-the-rest-8}
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.48\textwidth}
\begin{flushright}
\includegraphics[width=\textwidth]{prop-rule-the-rest-9}
\includegraphics[width=\textwidth]{prop-rule-the-rest-10}
\includegraphics[width=\textwidth]{prop-rule-the-rest-11}
\includegraphics[width=\textwidth]{prop-rule-the-rest-12}
\includegraphics[width=\textwidth]{prop-rule-the-rest-13}
\includegraphics[width=\textwidth]{prop-rule-the-rest-14}
\includegraphics[width=\textwidth]{prop-rule-the-rest-15}
\end{flushright}
\end{minipage}

    \caption{Main Rules for Propositional Logic}
\label{fig:prop-rule-main-rules}
\end{figure}

For example, these rules can be used together with \prule{hypothesis} as the
following

\begin{center}
  \includegraphics[scale=0.4]{prop-ex-thm-1}
\end{center}
\begin{center}
  \includegraphics[scale=0.4]{prop-ex-thm-2}
\end{center}

\section{Classical Logic}

The rules so far create Intuitionistic Logic i.e.\ it doesn't assume that each
proposition must be either true or false. Hence, cannot prove some thing like
\term{prop-term-lem-big-a}.

We can introduce rule \prule{proof-by-contradiction}, which is equivalent to
axiom \prule{law-of-exclude-middle} or \prule{double-negation-elim}, to make
Intuitionistic Logic become Classical one.

\begin{center}
\includegraphics[scale=0.4]{prop-rule-the-rest-16}
\end{center}

And now we can prove \pthm{law-of-exclude-middle} and
\pthm{double-negation-elim} as lemmas.

\begin{center}
  \includegraphics[scale=0.4]{prop-law-of-excluded-middle}
\end{center}

\begin{center}
  \includegraphics[scale=0.4]{prop-double-negation-elim}
\end{center}

\hspace{1ex}

For example, this example only holds only under Classical Logic.

\hspace{1ex}

\begin{center}
  \includegraphics[scale=0.4]{prop-ex-thm-3}
\end{center}

\newpage

\section{Validity of Proposition}

Although we prove validity of \pgmr{Judgement} to show that a curtain proposition
holds under curtain assumptions. But \pgmr{Prop} it self has meaning of validity
as well, that is, a proposition holds without any assumptions. Hence, we could
introduce a rule to prove stand alone \pgmr{Prop} like this.

\begin{figure}[H]
    \centering
  \includegraphics[scale=0.5]{prop-rule-prop-intro}
\caption{Rule that allow to prove \pgmr{Prop} directly}
\label{fig:prop-rule-prop-intro}
\end{figure}

For example, the following theorem shows that \term{prop-ex-thm-4-term} always holds
no matter of what \pvar{A} or \pvar{B} will be

\begin{center}
  \includegraphics[scale=0.4]{prop-ex-thm-4}
\end{center}

\hspace{1ex}

\section{Context manipulation}

Context in Propositional Logic is just a set of assumption so the order and
duplication among assumptions shouldn't matter. The three rules below allow
context to be manipulated during proving a theorem.

\begin{figure}[H]
    \centering
  \includegraphics[scale=0.5]{prop-context-comm}\\
  \includegraphics[scale=0.5]{prop-context-idem-1}\\
  \includegraphics[scale=0.5]{prop-context-idem-2}
\caption{Rule for context manipulation}
\label{fig:prop-context-munipulation}
\end{figure}

You can TODO:

\section{How to build Grammars and Rules}

So far we introduce grammars and rules out of the box, this allows user to prove
a theorem which is the most important part directly. However, Phometa also have
ability to create new grammars and rules as well.

To show how these can be built. I will recreate \pgmr{Prop} for grammars and
recreate \prule{and-intro} and \prule{hypothesis} for rules.

The first step, we need to press ``Add Grammar'' on one of adding panels in
module ``Propositional Logic'', then enter the grammar name. I will use
``TutorialProp'' to avoid conflict with the real one.

\section{Exercises}
TODO:

\end{document}